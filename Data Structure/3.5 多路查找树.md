# 多路查找树

因为数据处理都是在内存中完成的，而数据量比较大的时候，通常都是被存储在硬盘中。所以，当数据量非常大的时候，大到内存无法处理的时候，我们就需要不断重硬盘等存储设备中调入调出内存页面。

当涉及外部存储设备的时候，除了要考虑寻找元素时所需的比较次数，还需要考虑访问外部设备时所花费的时间。因此，为了解决这种问题，我们就需要新的数据结构来处理这样的问题，即多路查找树。

**多路查找树**的每个结点的孩子数可以多于两个，每个结点可以存储多个元素。这样，我们每次访问其结点的时候，就可以读取出大量的数据，从而减少了与外部存储设备交互的时间。多路查找树有几种特殊的形式：2-3树、2-3-4树、B树和B+树。

## 1、B树

B树是一种平衡多路查找树，2-3树和2-3-4树是B树的特例。结点最大的孩子数目是B树的阶。

一棵m阶的B树具有如下属性：

1. 如果根结点不是叶结点，则其至少有两棵子树；
2. 每一个非根的分支结点都有k-1个元素和k个孩子，其中k大于等于m/2的向下取整，小于等于m. (也就是以6阶为例，每个分支都有2-5个元素，3-6个孩子)
3. 每个叶子结点n都有k-1个元素，其中k大于等于m/2的向下取整，小于等于m；
4. 所有叶子节点都位于同一层次；
5. 每个结点中的关键字已非降序排列；
6. 子树中保存的关键字与根结点的关键字的大小关系与2-3树类似。

如果n≥1，那么对任意一棵包含n个关键字、高度为h、最小度数t≥2的B树T，有h≤log<sub>t</sub>[(n+1)/2].

在内存中我们只需要保存根结点的指针就可以了，假如每个结点中保存1000个关键字，那么我们想要保存10亿条记录只需要一棵高度为3的树就可以`(1000*1000*1000)`。我们第一次访问存储设备的时候，只需要用根结点的指针读取出来根结点，即1000个元素，然后在这1000个元素中找到我们要查找的元素所在的子树的位置；然后，再访一次存储设备读取出子树中的1000条记录，并再次查找指定的元素在子树中的位置；最后，我们再从读取出的子树的1000条记录中找到我们要查找的记录即可。

也就是，想要在保存了10亿条记录的存储设备中查找指定的值，我们只进行了三次存储设备的访问(最差的情况)。

### 1.2 B树的插入操作

![](http://files.cnblogs.com/yangecnu/btreebuild.gif)

B树的插入操作其实和2-3树是类似的，这里包含了一个叫做“页分裂”的操作，其实就是当指定的结点能够加入的关键字数目达到了最大值的时候，将指定的结点分裂成一棵子树，并将子树的根结点“进位”到父结点中，如果父结点达到了能够加入的最大值，它也进行一次分裂。

## 2、B+树

上面所说的B树虽然解决了外部存储的IO问题，但是它仍然有自己的局限性。比如，它无法进行范围查找的效率不高，使用它进行遍历的效率也不够高。为了解决这些问题，我们可以使用B+树。

B+树和B树基本相同，

![](http://upload.ouliu.net/i/20171027220415yjajj.png)

如图所示的是一棵B+树，我们可以来看一下，并总结一下它的特征：

1. 分支结点中的元素会被放到叶子结点后面，那些被放在后面的结点是该分支进行遍历的时候的中序后继者；
2. 每个叶子结点都包含了一个指向下一个叶子结点的指针。

那么，加入了这两个条件有什么好处呢？

1. 我们可以直接使用指针移动来得到该树的中序遍历结果；
2. 我们可以使用指针移动来得到所有元素的排序结果，即中序遍历结果；
3. 我们可以通过移动指针来得到指定范围的数据；
4. 分支结点可以看成是索引，结点中包含其子树中最大或最小关键字（也就是上面的3,5,8可以被看作索引，分别代表它们子树中的最大值）。

B树的插入和删除操作都与B树类似，只是所有的操作都在叶子结点上面进行而已：

![](http://files.cnblogs.com/yangecnu/Bplustreebuild.gif)

