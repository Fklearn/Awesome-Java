# 图

## 4、最小生成树

最小生成树(MST)：给定一幅图是**加权无向图**，它的最小生成树是权值最小的生成树。

树的两个最重要的**性质**：

1. 用一条边连接树中的任意两个顶点都会产生一个新的环；
2. 从树中删除一条边将会得到两棵独立的树。

图的一种切分是将图的所有顶点分为两个非空且不重叠的集合，**横切边**是连接两个属于不同集合的顶点的边。

**切分定理**：在一幅加权图中，给定任意的切分，它的**横切边**中的权重最小者必然属于图的最小生成树。

上面的切分定理很容易证明，了解它的思想也就更容易理解最小生成树的算法实现原理。假如最小生成树为T，自小的切分边为e，现在假设e不在T中，而是f。如果我们在T中加入了e，那么T就构成了一个环，这时候如果我们将f删掉，那么e就和T剩下的部分构成了最小生成树，从而和开始为最小生成树矛盾。

### 4.1 加权无向图的数据类型

在加权无向图中，我们除了要定义一条边的两个顶点，还要定义边的权重。下面是加权无向图的数据结构，我们将边抽象成一个类`Edge.class`。

	public class Edge implements Comparable<Edge> { 
	    private final int v;
	    private final int w;
	    private final double weight;

	    public Edge(int v, int w, double weight) {
	        this.v = v;
	        this.w = w;
	        this.weight = weight;
	    }
	
	    public double weight() { return weight; }
	
        // 返回边的两个顶点中的任意一个，因为边是无向的
	    public int either() { return v; }
	
        // 在已知一个顶点vertex的情况下，获取边的另一个顶点
	    public int other(int vertex) {
	        if (vertex == v) return w;
	        else if (vertex == w) return v;
	        else throw new IllegalArgumentException("Illegal endpoint");
	    }

	    @Override
	    public int compareTo(Edge that) {
	        return Double.compare(this.weight, that.weight);
	    }
	}

有了边的类之后，我们使用它来定义图的数据类型。这里adj是一个数组，数组的索引是顶点的值，数组中的背包中存储的是该顶点相连的所有的边。

	public class EdgeWeightedGraph {
	    private final int V; // 顶点总数
	    private int E; // 边的总数
	    private Bag<Edge>[] adj; // 邻接表
	    
	    public EdgeWeightedGraph(int V) {
	        this.V = V;
	        this.E = 0;
	        adj = (Bag<Edge>[]) new Bag[V];
	        for (int v = 0; v < V; v++) {
	            adj[v] = new Bag<Edge>();
	        }
	    }
	
	    public int V() { return V; }
	
	    public int E() { return E; }
	
        // 无向图中加入新的边的时候，要在两个顶点的边的集合中都加入该边的记录
	    public void addEdge(Edge e) {
	        int v = e.either();
	        int w = e.other(v);
	        adj[v].add(e);
	        adj[w].add(e);
	        E++;
	    }
	
	    public Iterable<Edge> adj(int v) { return adj[v]; }

	    public Iterable<Edge> edges() {
	        Bag<Edge> list = new Bag<Edge>();
	        for (int v = 0; v < V; v++) {
	            int selfLoops = 0;
	            for (Edge e : adj(v)) {
	                if (e.other(v) > v) {
	                    list.add(e);
	                } else if (e.other(v) == v) {
	                    if (selfLoops % 2 == 0) list.add(e);
	                    selfLoops++;
	                }
	            }
	        }
	        return list;
	    }
	}

### 4.2 Prim算法

其实要理解Prim算法很简单，它就是从一个结点开始，将该与该结点相连的边作为最小生成树的一条边，然后再从与该边的另一个顶点相连的所有边中选择一个权重最小的边，依次进行下去。就是说，每次都找该与该顶点相连的所有边中权重最小的一个。只是要注意的事情是，在选择边的时候已经加入了边不能重复加入，还不能N引入环。

至于为什么每次都要选择与一个顶点相连的最小的边：和上面讨论切分定理类似，假如我们认定它不在树中，那么如果我们将其加入树中就想成了环，然后将另一条边去掉就得到了一个权重更小的生成树。显然与假设是矛盾的。

#### 4.2.1 Prim算法的延迟实现

该算法就是从一个顶点开始，找与该顶点相连的所有边中权重最小的边（最小生成树的边）；找以上权重最小的边的另一个顶点，找与该顶点相连的权重最小的边（最小生成树的边）；找以上权重最小的边的另一个顶点，找……按照这样的方式来不断地获取最小生成树的边。

这里通过marked来记录最小生成树的顶点，如果一条边的两个顶点都在里面就表示该边失效了。这里使用pq表示树的横切边。它是一个优先队列，每次都从中移除最小权重的边进行判断，来决定它是否是最小生成树的边。每次在遇到某个顶点的时候，我们都将与该顶点相连的所有边加入该集合中。

	public class LazyPrimMST {
	    private double weight; // 最小生成树的权重
	    private Queue<Edge> mst; // 最小生成树的边的集合
	    private boolean[] marked; // 如果v在树中就标记marked[v]=true
	    private MinPQ<Edge> pq; // 横切边（包括失效的边）
	
	    public LazyPrimMST(EdgeWeightedGraph G) {
	        mst = new Queue<Edge>();
	        pq = new MinPQ<Edge>();
	        marked = new boolean[G.V()];
	        for (int v = 0; v < G.V(); v++) { // 使用全部顶点执行Prim算法来获取最小生成树
	            if (!marked[v]) {
                    prim(G, v);
	            }
            }
        }
	
	    private void prim(EdgeWeightedGraph G, int s) {
	        scan(G, s);
	        while (!pq.isEmpty()) {
	            Edge e = pq.delMin(); // 从pq中移除权重最小的边
	            int v = e.either(), w = e.other(v);
	            if (marked[v] && marked[w]) {
                    continue; // 虽然该边权重最小，但是该边已经被记录过了，所以是无效的
                } 
	            mst.enqueue(e); // 将最小生成树的边加入集合中
	            weight += e.weight(); // 最小生成树的权重
	            if (!marked[v]) scan(G, v); // 将与v相连的所有边的顶点加入pq中
	            if (!marked[w]) scan(G, w); // 将与w相连的所有边的顶点加入pq中
	        }
	    }

        private void scan(EdgeWeightedGraph G, int v) {
            marked[v] = true;
            for (Edge e : G.adj(v)) {
                if (!marked[e.other(v)]) {
                    pq.insert(e);
                }
            }
        }
	}

**性能**

Prim算法的延时版本中实现一幅含有V个顶点和E条边的连通加权无向图的最小生成树所需的空间与E成正比，所需的时间与ElogE成正比。

#### 4.2.2 Prim算法的即时实现

下面是Prim算法的即时实现，它依赖于[IndexMinPQ.java](http://algs4.cs.princeton.edu/43mst/IndexMinPQ.java.html)。

	public class PrimMST {
	    private Edge[] edgeTo;        // edgeTo[v] = shortest edge from tree vertex to non-tree vertex
	    private double[] distTo;      // distTo[v]=weight of shortest such edge
	    private boolean[] marked;     // 如果顶点v在树中，那么marked[v]=true
	    private IndexMinPQ<Double> pq; // 有效的横切边
	
	    public PrimMST(EdgeWeightedGraph G) {
	        edgeTo = new Edge[G.V()];
	        distTo = new double[G.V()];
	        marked = new boolean[G.V()];
	        pq = new IndexMinPQ<Double>(G.V());
	        for (int v = 0; v < G.V(); v++) // 使用最大的Double类型初始化distTo
	            distTo[v] = Double.POSITIVE_INFINITY;
	        for (int v = 0; v < G.V(); v++)
	            if (!marked[v]) prim(G, v);
	    }
	
	    private void prim(EdgeWeightedGraph G, int s) {
	        distTo[s] = 0.0; // 用顶点0和权重0.0初始化pq
	        pq.insert(s, distTo[s]);
	        while (!pq.isEmpty()) {
	            int v = pq.delMin();
	            scan(G, v);
	        }
	    }
	
	    private void scan(EdgeWeightedGraph G, int v) {
	        marked[v] = true;
	        for (Edge e : G.adj(v)) {
	            int w = e.other(v);
	            if (marked[w]) continue; // v-w is 失效的边
	            if (e.weight() < distTo[w]) { // 实际上是比较操作来得到与顶点v相连的边种权重最小一个
	                distTo[w] = e.weight();
	                edgeTo[w] = e;
	                if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
	                else                pq.insert(w, distTo[w]);
	            }
	        }
	    }
	}

**性能**

Prim算法的即使实现计算一个含有V个顶点和E条边的连通加权无向图的最小生成树所需的空间和V成正比，所需的时间和ElogV成正比。

### 4.3 Kruskal算法

它依赖于[UF.java](http://algs4.cs.princeton.edu/43mst/UF.java.html)。

	public class KruskalMST {
	    private double weight;                        // weight of MST
	    private Queue<Edge> mst = new Queue<Edge>();  // edges in MST
	
	    public KruskalMST(EdgeWeightedGraph G) {
	        // more efficient to build heap by passing array of edges
	        MinPQ<Edge> pq = new MinPQ<Edge>();
	        for (Edge e : G.edges()) {
	            pq.insert(e);
	        }
	
	        // run greedy algorithm
	        UF uf = new UF(G.V());
	        while (!pq.isEmpty() && mst.size() < G.V() - 1) {
	            Edge e = pq.delMin();
	            int v = e.either();
	            int w = e.other(v);
	            if (!uf.connected(v, w)) { // v-w does not create a cycle
	                uf.union(v, w);  // merge v and w components
	                mst.enqueue(e);  // add edge e to mst
	                weight += e.weight();
	            }
	        }
	
	        // check optimality conditions
	        assert check(G);
	    }
    }

Kruskal算法计算一个含有V个顶点和E条边的连通加权无向图的最小生成树所需的空间和E成正比，所需的时间和ElogE成正比。