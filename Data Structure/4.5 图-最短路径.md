# 图

## 5、最短路径

**单点最短路径**：给定一幅加权有向和一个起点s，计算从s到给定的目的顶点v的权重之和最小的路径。

**性质**：

1. 路径是有向的
2. 权重不一定等价于距离（也可以是其他的某种花费，所以可以将最短路径应用于其他场景）
3. 并不是所有的顶点都是可达的
4. 负权重会使问题更加复杂
5. 最短路径一般都是简单的
6. 最短路径不一定是唯一的
7. 可能存在平行环和自环

### 5.1 加权有向图的数据结构

#### 5.1.1 加权有向图的边

	public class DirectedEdge { 
	    private final int v;          // 边的起点
	    private final int w;          // 边的终点
	    private final double weight;  // 边的权重
	
	    public DirectedEdge(int v, int w, double weight) {
	        this.v = v;
	        this.w = w;
	        this.weight = weight;
	    }
	
	    public int from() { return v; }
	
	    public int to() { return w; }
	
	    public double weight() { return weight; }
	}

#### 5.1.2 加权有向图

以上是加权有向图的边的定义。我们可以利用上述的边，来实现加权有向图的定义：

	public class EdgeWeightedDigraph {
	    private final int V;                // 顶点的总数
	    private int E;                      // 边的总数
	    private Bag<DirectedEdge>[] adj;    // 邻接表
	    
	    public EdgeWeightedDigraph(int V) {
	        this.V = V;
	        this.E = 0;
	        this.indegree = new int[V];
	        adj = (Bag<DirectedEdge>[]) new Bag[V];
	        for (int v = 0; v < V; v++)
	            adj[v] = new Bag<DirectedEdge>();
	    }
	
	    public void addEdge(DirectedEdge e) {
	        adj[e.from()].add(e);
	        E++;
	    }
	
	    public int V() { return V; }
	
	    public int E() { return E; }
	}

#### 5.1.3 最短路的API

	public class SP {
	    private double[] distTo;          // distTo[v] 代表 s->v 的最短路径
	    private DirectedEdge[] edgeTo;    // edgeTo[v] 代表 s->v 路径的最后一条边
	
	    public DijkstraSP(EdgeWeightedDigraph G, int s) {
	        distTo = new double[G.V()];
	        edgeTo = new DirectedEdge[G.V()];
	
	        for (int v = 0; v < G.V(); v++)
	            distTo[v] = Double.POSITIVE_INFINITY;
	        distTo[s] = 0.0;
	    }
	
        // 从顶点 s 到 v 的距离，无穷大代表不存在
	    public double distTo(int v) {
	        return distTo[v];
	    }
	
	    public boolean hasPathTo(int v) {
	        return distTo[v] < Double.POSITIVE_INFINITY;
	    }
	
	    public Iterable<DirectedEdge> pathTo(int v) {
	        if (!hasPathTo(v)) return null;
	        Stack<DirectedEdge> path = new Stack<DirectedEdge>();
	        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()]) {
	            path.push(e);
	        }
	        return path;
	    }
	}

#### 5.1.4 边的松弛

以下是边的松弛的算法，

	private void relax(DirectedEdge e) {
	    int v = e.from(), w = e.to();
	    if (distTo[w] > distTo[v] + e.weight()) {
	        distTo[w] = distTo[v] + e.weight();
	        edgeTo[w] = e;
	    }
	}

我们可以结合下图来理解边的松弛的意义：

[pic]()

所以边的松弛就是：是s->w的路径比较短，还是从s->v再v->w比较短。注意这里的s->w表示的是一个s到w的路径，s->v是s到v的路径，而v->w是一条边。

#### 5.1.5 顶点的松弛

和上面的边的松弛类似，下面是顶点的松弛：

[pic]()

	private void relax(EdgeWeightedDigraph G, int v) {
         for(DirectedEdge e : G.adj(v)) {
    	    int w = e.to();
		    if (distTo[w] > distTo[v] + e.weight()) {
		        distTo[w] = distTo[v] + e.weight();
		        edgeTo[w] = e;
		    }
         }
	}

其实这里相当于对与v相邻的全部的边进行松弛：判断是s->w1, s->w2, s->w3...比较短，还是s->v再v->w1, v->w2, v-w3...比较短。(w1, w2, w3...表示以v为起点的所有的边的终点)

### 5.2 最短路径

#### 5.2.1 理论基础

**最短路径的最优性条件**：令G为一幅加权有向图，顶点s是G中的起点，distTo[]是一个由顶点索引的数组，保存的是G中路径的长度。对于从s可达的所有顶点v，distTo[v]的值是从s到v的某条路径的长度，对于从s不可达的所有顶点v，该值为无穷大。当且仅当对于从v到w的任意一条边e，这些值满足distTo[w]<=distTo[v]+e.weight()时，它们是最短路径的长度。

**通用最短路径算法**：将distTo[s]初始化为0，其他distTo[]元素初始化为无穷大，继续如下操作：放松G中的任意边，直到存在有效边为止。对于任意从s可达的顶点w，在进行这些操作之后，distTo[w]的值即为从s到w的最短路径的长度（且edgetT[w]的值即为该路径上的最后一条边）。

#### 5.2.2 算法的核心部分

	public class DijkstraSP {
	    private double[] distTo;          // distTo[v] 代表 s->v 的最短路径
	    private DirectedEdge[] edgeTo;    // edgeTo[v] 代表 s->v 路径的最后一条边
	    private IndexMinPQ<Double> pq;    // 矩阵的优先队列
	
	    public DijkstraSP(EdgeWeightedDigraph G, int s) {
	        distTo = new double[G.V()];
	        edgeTo = new DirectedEdge[G.V()];
	
	        for (int v = 0; v < G.V(); v++)
	            distTo[v] = Double.POSITIVE_INFINITY;
	        distTo[s] = 0.0;
	
	        pq = new IndexMinPQ<Double>(G.V());
	        pq.insert(s, distTo[s]);
	        while (!pq.isEmpty()) {
	            int v = pq.delMin();
	            for (DirectedEdge e : G.adj(v))
	                relax(e);
	        }
	    }
	
	    private void relax(DirectedEdge e) {
	        int v = e.from(), w = e.to();
	        if (distTo[w] > distTo[v] + e.weight()) {
	            distTo[w] = distTo[v] + e.weight();
	            edgeTo[w] = e;
	            if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
	            else                pq.insert(w, distTo[w]);
	        }
	    }
	}



