# Java内存模型与线程

## 1、Java内存模型

**Java内存模型**用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。Java内存模型的主要目标是定义程序中各个变量的访问规则。这里的变量是指在线程之间共享的变量。

Java内存模型规定了所有的变量都存储在**主内存**中，每天线程还有自己的**工作内存**，线程的工作内存保存了该线程需要使用到的变量的内存副本的拷贝。线程对变量的所有操作都必须在工作内存中完成，而不能直接读写主内存中的变量。如下图所示，

![](http://images.cnitblog.com/i/475287/201403/091134177063947.jpg)

### 1.1 内存间交互操作

Java内存模型规定了8种操作用来实现主内存和工作内存之间的同步：

1. **lock（锁定）**：作用于主内存的变量，把一个变量标识为一条线程独占状态。
2. **unlock（解锁）**：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
3. **read（读取）**：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。
4. **load（载入）**：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
5. **use（使用）**：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
6. **assign（赋值）**：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
7. **store（存储）**：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
8. **write（死如）**：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。

如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：

1. 不允许read和load、store和write操作之一单独出现
2. 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
3. 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。
4. 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
5. 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现
6. 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
7. 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
8. 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。

上面的8种操作加上8种规则，另外加上下面的volatile才保证了Java并发访问的安全性。

### 1.2 volatile

该关键字具有两种特性：

1. 保证此变量对所有线程的可见性，即当一条线程修改了这个变量的值，新值对其他立即可见的，而普通变量的值在线程间传递需要经过主内存来完成。虽然volatile变量在各个工作内存中不存在一致性问题，但是如果Java中的运算操作是非原子的，那么依然会存在并发问题。下面的代码说明了这种情况，

	    private static volatile int count = 0;
	
	    public static void main(String...args) {
	        int THREAD_COUNT = 20;
	        Thread[] threads = new Thread[THREAD_COUNT];
	
	        for (int i = 0; i< THREAD_COUNT; i++) {
	            threads[i] = new Thread(new Runnable() {
	                public void run() {
	                    for (int i=0;i<1000;i++) {
	                        count++;
	                    }
	                }
	            });
	            threads[i].start();
	        }
	
	        while (true) {
	            int cnt = 0;
	            for (int i = 0; i< THREAD_COUNT; i++) {
	                if (!threads[i].isAlive()) {
	                    cnt++;
	                }
	            }
	            if (cnt == THREAD_COUNT) {
	                break;
	            }
	        }
	
	        System.out.println("count:" + count);
	    }

    上述程序的计算结果不稳定，存在并发问题。它不总是得到20000. 这是因为++操作不是原子的，当一个线程计算完了结果的时候，其他线程可能已经将race的值更新过了。

2. 使用volatile的第二个语义是禁止指令重排序优化。普通变量只能保证该获取该变量的地方能够获取到正确的结果，但是不能保证赋值操作的顺序与代码中的执行顺序一致。因为在有些情况下，代码编译之后操作的顺序会与我们在代码中定义的不一样，这种在单线程中可能没有问题，但是在多线程环境中就会存在一些问题。典型的就是，我们定义的语句中两个线程，A用来初始化变量，B用来读取变量。如果使用了重排序可能会导致A还没有初始化变量，B就已经读取了变量。

### 1.3 long和double类型的特殊规定

允许没有被volatile修饰的long和double类型的变量读写操作分成两个32位操，不过实际上目前大多数虚拟机都将其设置成了原子的了。

## 2、Java与线程

### 2.1 线程的实现

线程是CPU调度的基本单位，通常线程的实现方式有：

1. 使用内核线程实现
	
    内核线程就是直接由操作系统内核支持的线程，这种线程由内核完成线程切换和调度，并将线程映射到各个处理器上。

    程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级线程，每个轻量级线程都由一个内核线程支持。

2. 使用用户线程实现

    广义的用户线程是，只要不是内核线程就是用户线程；侠义上的用户线程是指完全建立在用户空间的线程库上面的线程，系统内核无需帮助实现线程。它的优势在于不用内核线程支持，劣势也是因为不用内核线程支持而需要非常复杂、甚至无法完成的实现。

3. 用户线程与轻量级线程混合

    即将内核线程与轻量级线程混合使用的方式。

4. Java的线程实现

    在JDK1.2之前使用居于称为“绿色线程”的用户线程实现，在之后使用基于操作系统的原生线程模型实现。


