# JVM扫盲

## 1、关于Java

Java程序设计语言、Java虚拟机、Java API类库这三部分统称为JDK，JDK是用于支持Java程序开发的最小环境。
Java API类库中的Java SE API子集和Java虚拟机这两部分统称为JRE，JRE是支持Java程序运行的标准环境。

HotSpot是目前使用最为广泛的虚拟机。

Java以后发展的几个方向：1).模块化，功能组件可插拔；2).混合语言：各不同的功能模块使用不同的运行在虚拟机之上的语言开发；
3).多核并行：使用分治算法等提升多核利用率；4).丰富现有的语法，5).解决64位虚拟机上的性能问题。

## 2、JVM内存管理

### 2.1 JVM内存区域

![虚拟机内存区域](res/jvm_data_area.png)

上面的图展示的就是JVM运行时的数据区域。大致分成以上几个部分，我们这里对各个部分功能做简要的总结：

1. **程序计数器**：线程私有，用来指示当前线程所执行的字节码的行号，就是用来标记线程现在执行的代码的位置；
对Java方法，它存储的是字节码指令的地址；对于Native方法，该计数器的值为空。
2. **栈**：线程私有，一个方法的执行和退出就是用一个栈帧的入栈和出栈表示的，通常我们不允许你使用递归就是因为，方法就是一个栈，太多的方法只执行而没有退出就会导致栈溢出，不过可以通过尾递归优化。栈又分为虚拟机栈和本地方法栈，一个对应Java方法，一个对应Native方法。
3. **堆**：用来给对象分配内存的，几乎所有的对象实例（包括数组）都在上面分配。它是垃圾收集器的主要管理区域，因此也叫GC堆。它实际上是一块内存区域，由于一些收集算法的原因，又将其细化分为新生代和老年代等。
4. **方法区**：方法区由多线程共享，用来存储类信息、常量、静态变量、即使编译后的代码等数据。运行时常量池是方法区的一部分，它用于存放编译器生成的各种字面量和符号引用，比如字符串常量等。

### 2.2 垃圾回收

根据上面JVM内存区域的描述，我们知道程序计数器和两种栈的生命周期与线程相同，线程或者方法结束即可回收。
所以，所谓的垃圾回收主要是针对方法区和堆内存而言。

#### 生存还是死亡

*可达性分析 四种引用类型 对象的自我救赎*

判断一个对象是否可以回收通用的方式有两种。
一种是**引用记数法**，即给对象添加一个引用计数器，被引用时计数器加1，引用失效时减1。
这种方法不常用，因为它难以解决两个变量相互引用的问题。
另一种是**可达性分析**，即通过一系列GC Roots的对象作为起始点，从节点向下搜索，
当一个对象没有任何一条可到GC Roots的引用链，则该对象可回收。

根据**可达性分析**的原理，对象之间存在引用关系，但是“是或否被引用”不足以描述更多的场景，
所以在这基础之上人们又提出了四种引用类型的概念：强引用、软引用、弱引用和虚引用，它们的引用强度依次减弱。

当使用`new`关键字创建一个对象的时候，这个对象就是`强引用`的，它绝对不会被回收，即使内存耗尽。
你可以通过将其置为`null`来弱化对其的引用，但什么时候被回收还要取决于gc的算法。
`软引用`和`弱引用`相似，你可以分别通过`SoftReference<T>`和`WeakReference<T>`来使用它们，它们的区别仅在于后者更弱一些。
实际开发中，软引用使用较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出。
而`虚引用`在任何时候都可能被垃圾回收器回收。

当一个对象不再被引用的时候，该对象也不一定被回收，理论上它还有一次救赎的机会，即通过覆写`finilize()`方法把对自己的引用从弱变强，即把自己赋值给全局的对象等。因为当对象不可达的时候，只有当`finilize()`没被覆写，或者`finilize()`已经被调用过，则该对象会被回收。否则，它会被放在一个队列中，并在稍后由一个低优先级的Finilizer线程执行它。所以，我们可以通过这个机制来完成救赎，但实际上没有必要那么干，因为覆写`finilize()`是不推荐的。

#### 垃圾回收算法

*标记-清除算法 复制算法 标记-整理算法 分代收集算法*

![标记-清除算法](http://images.cnitblog.com/i/288799/201406/181024382398115.jpg)

第一回收算法是**标记-清除算法**，这种算法直接在内存中把需要回收的对象“抠”出来。
好好的内存被它搞成了马蜂窝，所以效率不高，清除之后会产生内容碎片，造成内存不连续，当分配较大内存对象时可能会因内存不足而触发垃圾收集动作。

![复制算法](http://images.cnitblog.com/i/288799/201406/181041528488728.jpg)

`复制算法`将内存分成两块，一次只在一块内存中进行分配，垃圾回收一次之后，
就将该内存中的未被回收的对象移动到另一块内存中，然后将该内存一次清理掉。
比如将内存分成A和B，先在A中分配，当垃圾回收的时候把A中需要回收的内存清理掉，然后把不需要清理的所有对象复制到B里面。
`复制算法`常被用来回收新生代，而且分配空间也不是1:1，而是较大的Eden空间和较小的Survivor空间。在HotSpot中，其比例是8:1。

![标记-整理算法](http://images.cnitblog.com/i/288799/201406/181100129575916.jpg)

类似于`标记-清除`算法，只是回收了之后，它要对内存空间进行整理，以使得剩余的对象占用连续的存储空间。

上面是三种基本的垃圾回收算法，但实际上，我们通常根据对象存活周期的不同将内存划分成几块，然后根据其特点采用不同的回收算法。
这就是所谓的`分代收集算法`。

#### 垃圾收集器

*  Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1*

![垃圾收集器](https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3987877514,3271369785&fm=11&gp=0.jpg)

HotSpot当中共有7种垃圾回收器，按照它们负责区域，又可以分成三种：

1. 新生代收集器：Serial、ParNew、Parallel Scavenge；
2. 老年代收集器：Serial Old、Parallel Old、CMS；
3. 整堆收集器：G1；

当搭配起来使用的时候又可以得到以下几种组合关系： Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1




