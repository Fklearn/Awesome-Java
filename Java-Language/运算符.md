# 运算符

## 1 运算符（基本同C）

1. 增量运算符(++) ，注意++操作符的本质计算过程：
	
	Q：以下程序的输出结果是？
	
        int j = 0;
        for (int i = 0; i < 100; i++) {
            j = j++;
        }
        System.out.println(j);

	输出结果是0，这是因为`j=j++`操作等价于`int temp=j; j=j+1; j=temp;`

2. 减量运算符(--)    增量和减量出现在变量名前和变量名后的区别.
3. 一元运算符+和一元运算符-  
4. 算术运算符(+、-、*、/)    当参与/运算的两个操作数都是表示整数除法，否则是浮点数除法

	Q：以下两个表达式，哪个正确？

        short s = 1; s = s + 1;
        short s = 1; s += 1;

	第二个，因为`s+1`为int型，不能赋值给short类型。

5. 取模运算符(%)
6. 比较运输符(>、<、>=、<=、!=、==)
	1. 形如a<b<c的复合比较式要写成(a<b)&&(b<c)而不能是a<b<c
	2. 简单数据类型比较的是它的值；
	3. 引用类型比较的是两个引用是否指向同一对象实例，即是否指向同一内存位置；
	4. 引用类型的比较中，参与比较的两个引用类型必须能够转换为同一引用类型；
	5. null常量表示非空对象，可以与任何引用类型变量比较；
	6. 如果参与表决的两个操作数，一个为常量，则采用值比较方式，而非引用地址. 
	7. 引用类型的比较可以使用对应类的'equals(Object obj)'方法实现. 
	8. 比较运算符具有截断性，如果前面的能够得出表达式的结果就不再继续比较了，比如`if(obj != null && ebj.equals(obj2))`，这里如果ebj是null的话是不会进行equals比较的。
	9. **equals()方法默认比较引用，要想实现自己的比较逻辑必须覆写该方法。同时要注意equals()和hashCode()方法需要同时覆写。**
	10. 对浮点数的比较是非常严格的，即使一个数仅在小数部分与另一个数存在极微小的差异，仍然认为它们是不相等的。即使一个数比零大一点点，它仍然是非零的值。
7. 逻辑运算符： `!`(逻辑非)  `&`(逻辑与)  `^`(逻辑异或)  `|`(逻辑或)  `&&`(条件与)  `||`(条件或)
8. 字符串运算符：`+` 运算符用于串联两个字符串，对非字符串类型的通过调用从Object类继承的toString()方法将其转换为字符串形式.
	1. 错误的例子String s0 = true + false + “abc”; //错误(true+false)运算错误
	2. 其实+运算是每次创建一个`StringBuilder`对象，并调用它的append方法添加字符串，所以使用StringBuilder比使用+的效率更高
9. 位运算符：`~` (按位求补)  `<<` (左移位)  `>>` (右移位，高位填充符号位)  `>>>`(右移位，高位填充0)  `&` (逻辑与)  `^` (逻辑异或)  `|` (逻辑或)
	1. `32>>32`相当于`32>>0`，而`32>>33`相当于`32>>1`.
	2. `>>`和`>>>`的区别：
	
			System.out.println(Integer.toBinaryString(Integer.MAX_VALUE));
	        System.out.println(Integer.toBinaryString(Integer.MAX_VALUE >> 10));
	        System.out.println(Integer.toBinaryString(Integer.MAX_VALUE >>> 10));
	        System.out.println(Integer.toBinaryString(-1));
	        System.out.println(Integer.toBinaryString(-1 >> 10));
	        System.out.println(Integer.toBinaryString(-1 >>> 10));
	        System.out.println(-1 >> 1);
	        System.out.println(-1 >>> 1);
  	    
		输出结果：

			1111111111111111111111111111111
			111111111111111111111
			111111111111111111111
			11111111111111111111111111111111
			11111111111111111111111111111111
			1111111111111111111111
			-1
			4194303

		**说明**：左移位(<<)能按照操作符左侧指定的位数将操作符左边的操作数向左移动（在低位补0），“有符号”右移操作符(>>)按照操作符右侧指定的位数将从操作符左边的操作数向右移动；“有符号”右移操作符使用“符号拓展”：若符号位为证，则在高位插入0，若符号位为负，则在高位插入1。“无符号”右移操作符(>>>)，无论正负都在高位插入0.

10. 赋值运算符：要求右边的操作数可以隐式地转换为左边的操作数或类型相同. 
	1.复合赋值语句：` +=  -=  *=  /=  %=  <<=  >>=  &=  |=  ^=`
11. 条件运算符：Exp1 ? Exp2 : Exp3;

	Q：以下程序的输出结果是：

        char x = 'x';
        int i = 10;
        System.out.println(false ? i : x);
        System.out.println(false ? 10 : x);

	120和x，这是因为第一个输出中，i为int类型，第一个输出被提升为int型；第二个输出中，10是常量，常量10可以被char表示，故输出char型。

12. 其他运算符
	1. `.`访问对象的实例成员，或访问类的静态成员
	2. [ ]		用于数组声明、创建和访问
	3. ( )		方法调用
	4. (T)		将x显示地转换为类型T
	5. new		创建对象、数组
	6. instanceof		测试对象是否为类型T的实例

## 2 优先级与结合性

略