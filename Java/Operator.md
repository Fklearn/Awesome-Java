# 运算符

## 1 运算符（基本同C，特别说明几个）

|编号|运算符|说明|
|:-:|:-:|:-:|
|1|自增(++)/自减(--)运算符|注意它本质上是分3步执行的(所以非原子的)，运算符放在前面和后面会有区别(参考问题1)|
|2|算术运算符(+、-、*、/)|当参与`/`运算的两个操作数都是表示整数除法，否则是浮点数除法(注意类型转换，参考问题2)|
|3|比较运输符(>、<、>=、<=、!=、==)|参考总结1|
|4|字符串运算符(+)|运算符用于串联两个字符串，对非字符串类型的通过调用从Object类继承的toString()方法将其转换为字符串形式(参考总结2)|
|5|赋值运算符(+=  -=  *=  /=  %=  <<=  >>=  &=  &#124;=  ^=)|要求右边的操作数可以隐式地转换为左边的操作数或类型相同|

## 总结

### 1. 总结1：关于比较运算符

|编号|总结|
|:-:|:-:|
|1|形如`a<b<c`的复合比较式要写成`(a<b)&&(b<c)`而不能是`a<b<c`|
|2|简单数据类型比较的是它的值|
|3|引用类型比较的是两个引用是否指向同一对象实例，即是否指向同一内存位置|
|4|引用类型的比较中，参与比较的两个引用类型必须能够转换为同一引用类型|
|5|null常量表示非空对象，可以与任何引用类型变量比较|
|6|如果参与比较的两个操作数，一个为常量，则采用值比较方式，而非引用地址|
|7|引用类型的比较可以使用对应类的'equals(Object obj)'方法实现|
|8|比较运算符具有截断性，如果前面的能够得出表达式的结果就不再继续比较了，比如`if(obj != null && ebj.equals(obj2))`，这里如果ebj是null的话是不会进行equals比较的|
|9|equals()方法默认比较引用，要想实现自己的比较逻辑必须覆写该方法。同时要注意equals()和hashCode()方法需要同时覆写|
|10|对浮点数的比较是非常严格的，即使一个数仅在小数部分与另一个数存在极微小的差异，仍然认为它们是不相等的。即使一个数比零大一点点，它仍然是非零的值|

### 2. 总结2：关于字符串运算符

1. 错误的例子String s0 = true + false + “abc”; //错误(true+false)运算错误
2. 对于字符串，`+`运算是每次创建一个`StringBuilder`对象，并调用它的append方法添加字符串，所以使用StringBuilder比使用+的效率更高

### 3. 总结3：关于移位

1. `32>>32`相当于`32>>0`，而`32>>33`相当于`32>>1`.
2. `>>`和`>>>`的区别：

        System.out.println(Integer.toBinaryString(Integer.MAX_VALUE));         // 输出结果：1111111111111111111111111111111
	    System.out.println(Integer.toBinaryString(Integer.MAX_VALUE >> 10));   // 输出结果：111111111111111111111
        System.out.println(Integer.toBinaryString(Integer.MAX_VALUE >>> 10));  // 输出结果：111111111111111111111
        System.out.println(Integer.toBinaryString(-1));                        // 输出结果：11111111111111111111111111111111
        System.out.println(Integer.toBinaryString(-1 >> 10));                  // 输出结果：11111111111111111111111111111111
        System.out.println(Integer.toBinaryString(-1 >>> 10));                 // 输出结果：1111111111111111111111
        System.out.println(-1 >> 1);                                           // 输出结果：-1
        System.out.println(-1 >>> 1);                                          // 输出结果：4194303
  	    
3. 左移位(<<)能按照操作符左侧指定的位数将操作符左边的操作数向左移动（在低位补0）
4. “有符号”右移操作符(>>)按照操作符右侧指定的位数将从操作符左边的操作数向右移动；
5. “有符号”右移操作符使用“符号拓展”：若符号位为证，则在高位插入0，若符号位为负，则在高位插入1。
6. “无符号”右移操作符(>>>)，无论正负都在高位插入0.

## 问题

### 1. 问题1：以下程序的输出结果是？

    int j = 0;
    for (int i = 0; i < 100; i++) {
        j = j++;
    }
    System.out.println(j);

输出结果是0，这是因为`j=j++`操作等价于`int temp=j; j=j+1; j=temp;`

### 2.问题2: 以下两个表达式，哪个正确？

    short s = 1; s = s + 1;
    short s = 1; s += 1;

第二个，因为`s+1`为int型，不能赋值给short类型。第二个表达式中会被强制转型为short类型。

### 3.问题3：以下程序的输出结果是

    char x = 'x';
    int i = 10;
    System.out.println(false ? i : x);
    System.out.println(false ? 10 : x);

120和x，这是因为第一个输出中，i为int类型，第一个输出被提升为int型；第二个输出中，10是常量，常量10可以被char表示，故输出char型。
